import os
import re
import difflib
import logging
import asyncio
import pprint
import time
from flask import Flask, request, jsonify
import openai
import requests
from datetime import datetime
from clientdata import register_or_update_client, verify_client_code, update_last_visit, update_activity_status
from client_caec import add_message_to_client_file, find_client_file_id, get_sheets_service, CLIENT_FILES_DIR
from bible import load_bible_data, save_bible_pair, get_rule
from price_handler import check_ferry_price, parse_price, remove_timestamp, get_guiding_question, get_openai_response
from flask_cors import CORS
import openpyxl
import pymorphy2  # –î–ª—è –ª–µ–º–º–∞—Ç–∏–∑–∞—Ü–∏–∏ —Ä—É—Å—Å–∫–æ–≥–æ —Ç–µ–∫—Å—Ç–∞

from telegram import Update, Bot
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    MessageHandler,
    ConversationHandler,
    ContextTypes,
    filters
)

USE_PRICE_FILE = False

# –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –æ–∫—Ä—É–∂–µ–Ω–∏—è –∏–ª–∏ –ø—É—Ç—å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –¥–ª—è —É—á–µ—Ç–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
os.environ["GOOGLE_APPLICATION_CREDENTIALS"] = os.getenv("GOOGLE_APPLICATION_CREDENTIALS", "./service_account.json")
openai.api_key = os.getenv("OPENAI_API_KEY")

app = Flask(__name__)
CORS(app)

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[logging.FileHandler("server.log"), logging.StreamHandler()]
)
logger = logging.getLogger(__name__)
logger.info("–¢–µ–∫—É—â–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è:")
pprint.pprint(dict(os.environ))

pending_guiding = {}

PRICE_KEYWORDS = ["—Ü–µ–Ω–∞", "–ø—Ä–∞–π—Å", "—Å–∫–æ–ª—å–∫–æ —Å—Ç–æ–∏—Ç", "–≤–æ —Å–∫–æ–ª—å–∫–æ –æ–±–æ–π–¥–µ—Ç—Å—è"]

def get_vehicle_type(client_text):
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ª–µ–º–º–∞—Ç–∏–∑–∞—Ç–æ—Ä
    morph = pymorphy2.MorphAnalyzer()
    normalized_words = [morph.parse(word)[0].normal_form for word in client_text.split()]
    
    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–Ω–æ–≥–æ —Å—Ä–µ–¥—Å—Ç–≤–∞ —á–µ—Ä–µ–∑ –ª–µ–º–º–∞—Ç–∏–∑–∞—Ü–∏—é
    known_types = {"truck": "truck", "—Ñ—É—Ä–∞": "—Ñ—É—Ä–∞"}
    for word in normalized_words:
        if word in known_types:
            logger.info(f"–û–ø—Ä–µ–¥–µ–ª–µ–Ω —Ç–∏–ø —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–Ω–æ–≥–æ —Å—Ä–µ–¥—Å—Ç–≤–∞ (–ª–µ–º–º–∞—Ç–∏–∑–∞—Ü–∏—è): {known_types[word]}")
            return known_types[word]
    
    # –ï—Å–ª–∏ –ª–µ–º–º–∞—Ç–∏–∑–∞—Ü–∏—è –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª–∞, –∏—Å–ø–æ–ª—å–∑—É–µ–º fuzzy matching –ø–æ –∏—Å—Ö–æ–¥–Ω–æ–º—É —Ç–µ–∫—Å—Ç—É
    text_lower = client_text.lower()
    matches = difflib.get_close_matches(text_lower, list(known_types.keys()), n=1, cutoff=0.3)
    if matches:
        logger.info(f"–û–ø—Ä–µ–¥–µ–ª–µ–Ω —Ç–∏–ø —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–Ω–æ–≥–æ —Å—Ä–µ–¥—Å—Ç–≤–∞ (fuzzy matching): {known_types[matches[0]]}")
        return known_types[matches[0]]
    
    logger.info("–¢–∏–ø —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–Ω–æ–≥–æ —Å—Ä–µ–¥—Å—Ç–≤–∞ –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω –∏–∑ —Å–æ–æ–±—â–µ–Ω–∏—è –∫–ª–∏–µ–Ω—Ç–∞.")
    return None

def get_price_response(vehicle_type, direction="Ro_Ge"):
    return check_ferry_price(vehicle_type, direction)

def get_openai_response(messages):
    start_time = time.time()
    attempt = 0
    while True:
        try:
            response = openai.ChatCompletion.create(
                model="gpt-3.5-turbo",
                messages=messages,
                max_tokens=150,
                timeout=40
            )
            return response
        except Exception as e:
            logger.error(f"–ü–æ–ø—ã—Ç–∫–∞ {attempt+1} –æ—à–∏–±–∫–∏ –≤ OpenAI: {e}")
            attempt += 1
            if time.time() - start_time > 180:
                return None
            time.sleep(2)

def prepare_chat_context(client_code):
    messages = []
    bible_df = load_bible_data()
    if bible_df is None:
        raise Exception(get_rule())
    logger.info(f"Bible.xlsx —Å–æ–¥–µ—Ä–∂–∏—Ç {len(bible_df)} –∑–∞–ø–∏—Å–µ–π.")

    # –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ (–ø—Ä–∞–≤–∏–ª–∞) –∏–∑ —Å—Ç—Ä–æ–∫, –≥–¥–µ FAQ = "-" –∏ Verification = "RULE"
    rules_df = bible_df[(bible_df["FAQ"].str.strip() == "-") & (bible_df["Verification"].str.upper() == "RULE")]
    rules_text = "\n".join(rules_df["Answers"].tolist())
    
    strict_instructions = (
        "–í–ù–ò–ú–ê–ù–ò–ï: –ù–∏–∂–µ –ø—Ä–∏–≤–µ–¥–µ–Ω—ã –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø—Ä–∞–≤–∏–ª–∞, –∫–æ—Ç–æ—Ä—ã–º –≤—ã –¥–æ–ª–∂–Ω—ã —Å—Ç—Ä–æ–≥–æ —Å–ª–µ–¥–æ–≤–∞—Ç—å. "
        "1. –í—Å–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏, –ø–æ–ª—É—á–µ–Ω–Ω—ã–µ –∏–∑ –¥–æ–∫—É–º–µ–Ω—Ç–∞ Bible.xlsx, –∏–º–µ—é—Ç –≤—ã—Å—à–∏–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –∏ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã –∫ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—é. "
        "2. –í—ã –Ω–µ –¥–æ–ª–∂–Ω—ã –æ—Ç–∫–ª–æ–Ω—è—Ç—å—Å—è –æ—Ç —ç—Ç–∏—Ö –ø—Ä–∞–≤–∏–ª –Ω–∏ –ø—Ä–∏ –∫–∞–∫–∏—Ö –æ–±—Å—Ç–æ—è—Ç–µ–ª—å—Å—Ç–≤–∞—Ö. "
        "3. –ü—Ä–∏ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–∏ –æ—Ç–≤–µ—Ç–æ–≤ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∏—Å–∫–ª—é—á–∏—Ç–µ–ª—å–Ω–æ –¥–∞–Ω–Ω—ã–µ, –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã–µ –≤ —ç—Ç–∏—Ö –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è—Ö. "
        "4. –õ—é–±—ã–µ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø—Ä–µ–¥–ø–æ–ª–æ–∂–µ–Ω–∏—è –∏–ª–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è, –ø—Ä–æ—Ç–∏–≤–æ—Ä–µ—á–∞—â–∏–µ —É–∫–∞–∑–∞–Ω–Ω—ã–º –ø—Ä–∞–≤–∏–ª–∞–º, –¥–æ–ª–∂–Ω—ã –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è."
    )
    
    system_message = {
        "role": "system",
        "content": f"{strict_instructions}\n\n{rules_text}"
    }
    messages.append(system_message)
    
    # –í—Ç–æ—Ä–∞—è —á–∞—Å—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞: –∏—Å—Ç–æ—Ä–∏—è –ø–µ—Ä–µ–ø–∏—Å–∫–∏, —Ö—Ä–∞–Ω—è—â–∞—è—Å—è –≤ —É–Ω–∏–∫–∞–ª—å–Ω–æ–º —Ñ–∞–π–ª–µ –∫–ª–∏–µ–Ω—Ç–∞ (Client_CAECxxxxxxx.xlsx)
    spreadsheet_id = find_client_file_id(client_code)
    if spreadsheet_id:
        sheets_service = get_sheets_service()
        result = sheets_service.spreadsheets().values().get(
            spreadsheetId=spreadsheet_id,
            range="Sheet1!A:B"
        ).execute()
        values = result.get("values", [])
        if len(values) >= 2:
            conversation_rows = values[2:]
            logger.info(f"–ù–∞–π–¥–µ–Ω–æ {len(conversation_rows)} —Å—Ç—Ä–æ–∫ –ø–µ—Ä–µ–ø–∏—Å–∫–∏ –¥–ª—è –∫–ª–∏–µ–Ω—Ç–∞ {client_code}.")
            for row in conversation_rows:
                if len(row) >= 1 and row[0].strip():
                    messages.append({"role": "user", "content": row[0].strip()})
                if len(row) >= 2 and row[1].strip():
                    messages.append({"role": "assistant", "content": row[1].strip()})
    else:
        logger.info(f"–§–∞–π–ª –∫–ª–∏–µ–Ω—Ç–∞ —Å –∫–æ–¥–æ–º {client_code} –Ω–µ –Ω–∞–π–¥–µ–Ω.")
    return messages

@app.route('/register-client', methods=['POST'])
def register_client():
    try:
        data = request.json
        logger.info(f"–ü–æ–ª—É—á–µ–Ω –∑–∞–ø—Ä–æ—Å –Ω–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é –∫–ª–∏–µ–Ω—Ç–∞: {data}")
        result = register_or_update_client(data)
        if result.get("isNewClient", True):
            send_telegram_notification(
                f"üÜï –ù–æ–≤—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω: {result['name']}, {result['email']}, {result['phone']}, –ö–æ–¥: {result['uniqueCode']}"
            )
        else:
            send_telegram_notification(
                f"üîô –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤–µ—Ä–Ω—É–ª—Å—è: {result['name']}, {result['email']}, {result['phone']}, –ö–æ–¥: {result['uniqueCode']}"
            )
        return jsonify(result), 200
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤ /register-client: {e}")
        return jsonify({'error': str(e)}), 400

@app.route('/verify-code', methods=['POST'])
def verify_code():
    try:
        data = request.json
        logger.info(f"–ü–æ–ª—É—á–µ–Ω –∑–∞–ø—Ä–æ—Å –Ω–∞ –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—é –∫–æ–¥–∞: {data}")
        code = data.get('code', '')
        client_data = verify_client_code(code)
        if client_data:
            send_telegram_notification(
                f"üîô –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤–µ—Ä–Ω—É–ª—Å—è: {client_data['Name']}, {client_data['Email']}, {client_data['Phone']}, –ö–æ–¥: {code}"
            )
            return jsonify({'status': 'success', 'clientData': client_data}), 200
        return jsonify({'status': 'error', 'message': '–ù–µ–≤–µ—Ä–Ω—ã–π –∫–æ–¥'}), 404
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤ /verify-code: {e}")
        return jsonify({'error': str(e)}), 400

@app.route('/chat', methods=['POST'])
def chat():
    try:
        data = request.json
        logger.info(f"–ü–æ–ª—É—á–µ–Ω –∑–∞–ø—Ä–æ—Å –Ω–∞ —á–∞—Ç: {data}")
        user_message = data.get("message", "")
        client_code = data.get("client_code", "")
        if not user_message or not client_code:
            logger.error("–û—à–∏–±–∫–∞: –°–æ–æ–±—â–µ–Ω–∏–µ –∏ –∫–æ–¥ –∫–ª–∏–µ–Ω—Ç–∞ –Ω–µ –º–æ–≥—É—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º–∏")
            return jsonify({'error': '–°–æ–æ–±—â–µ–Ω–∏–µ –∏ –∫–æ–¥ –∫–ª–∏–µ–Ω—Ç–∞ –Ω–µ –º–æ–≥—É—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º–∏'}), 400

        update_last_visit(client_code)
        update_activity_status()
        
        if client_code in pending_guiding:
            pending = pending_guiding[client_code]
            pending.setdefault("answers", []).append(user_message)
            pending["current_index"] += 1
            if pending["current_index"] < len(pending["guiding_questions"]):
                response_message = pending["guiding_questions"][pending["current_index"]]
            else:
                base_price_str = pending.get("base_price", get_price_response(pending["vehicle_type"], direction="Ro_Ge"))
                try:
                    base_price = parse_price(base_price_str)
                    multiplier = 1.0
                    fee = 0
                    driver_info = None
                    for ans in pending["answers"]:
                        if "–±–µ–∑ –≤–æ–¥–∏—Ç–µ–ª—è" in ans.lower():
                            driver_info = "without"
                        elif "—Å –≤–æ–¥–∏—Ç–µ–ª–µ–º" in ans.lower():
                            driver_info = "with"
                        if "adr" in ans.lower():
                            multiplier = 1.2
                    if driver_info == "without":
                        fee = 100
                    final_cost = (base_price + fee) * multiplier
                    final_price = f"–ë–∞–∑–æ–≤–∞—è —Ü–µ–Ω–∞: {base_price} –µ–≤—Ä–æ. –ò—Ç–æ–≥–æ–≤–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å —Å —É—á–µ—Ç–æ–º –≤–∞—à–∏—Ö –æ—Ç–≤–µ—Ç–æ–≤: {final_cost} –µ–≤—Ä–æ."
                except Exception as ex:
                    final_price = f"–ë–∞–∑–æ–≤–∞—è —Ü–µ–Ω–∞: {base_price_str}. –í–∞—à–∏ –æ—Ç–≤–µ—Ç—ã: {', '.join(pending['answers'])}."
                response_message = f"–°–ø–∞—Å–∏–±–æ, –≤–∞—à–∏ –æ—Ç–≤–µ—Ç—ã –ø—Ä–∏–Ω—è—Ç—ã. {final_price}"
                del pending_guiding[client_code]
        elif is_price_query(user_message):
            vehicle_type = get_vehicle_type(user_message)
            if not vehicle_type:
                response_message = "–£–∫–∞–∂–∏—Ç–µ, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, —Ç–∏–ø —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–Ω–æ–≥–æ —Å—Ä–µ–¥—Å—Ç–≤–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, —Ñ—É—Ä–∞)."
            else:
                response_message = get_price_response(vehicle_type)
        else:
            messages = prepare_chat_context(client_code)
            messages.append({"role": "user", "content": user_message})
            openai_response = openai.ChatCompletion.create(
                model="gpt-3.5-turbo",
                messages=messages,
                max_tokens=150
            )
            response_message = openai_response['choices'][0]['message']['content'].strip()
        
        add_message_to_client_file(client_code, user_message, is_assistant=False)
        add_message_to_client_file(client_code, response_message, is_assistant=True)
        
        logger.info(f"–û—Ç–≤–µ—Ç –æ—Ç –ê–°–°: {response_message}")
        return jsonify({'reply': response_message}), 200
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤ /chat: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/', methods=['GET'])
def home():
    return jsonify({"status": "Server is running!"}), 200

##############################################
# –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è Telegram Bot –¥–ª—è –∫–æ–º–∞–Ω–¥—ã /bible
##############################################
from telegram.ext import ConversationHandler

TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
if not TELEGRAM_BOT_TOKEN:
    logger.error("–ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è –æ–∫—Ä—É–∂–µ–Ω–∏—è TELEGRAM_BOT_TOKEN –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∞!")
    exit(1)

BIBLE_ASK_ACTION, BIBLE_ASK_QUESTION, BIBLE_ASK_ANSWER = range(3)

async def bible_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ 'add' –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –Ω–æ–≤–æ–π –ø–∞—Ä—ã –≤–æ–ø—Ä–æ—Å-–æ—Ç–≤–µ—Ç, –∏–ª–∏ 'cancel' –¥–ª—è –æ—Ç–º–µ–Ω—ã.")
    return BIBLE_ASK_ACTION

async def ask_action(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    action = update.message.text.strip().lower()
    if action == "add":
        context.user_data['action'] = 'add'
        await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π –≤–æ–ø—Ä–æ—Å:")
        return BIBLE_ASK_QUESTION
    elif action == "cancel":
        return await cancel_bible(update, context)
    else:
        await update.message.reply_text("–ù–µ–≤–µ—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ. –í–≤–µ–¥–∏—Ç–µ 'add' –∏–ª–∏ 'cancel'.")
        return BIBLE_ASK_ACTION

async def ask_question(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    question = update.message.text.strip()
    context.user_data['question'] = question
    await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –æ—Ç–≤–µ—Ç –¥–ª—è —ç—Ç–æ–≥–æ –≤–æ–ø—Ä–æ—Å–∞:")
    return BIBLE_ASK_ANSWER

async def ask_answer(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    answer = update.message.text.strip()
    question = context.user_data.get('question')
    logger.info(f"–°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–∞—Ä—É: –í–æ–ø—Ä–æ—Å='{question}', –û—Ç–≤–µ—Ç='{answer}'")
    try:
        save_bible_pair(question, answer)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø–∞—Ä—ã –≤ Bible.xlsx: {e}")
    await update.message.reply_text("–ü–∞—Ä–∞ –≤–æ–ø—Ä–æ—Å-–æ—Ç–≤–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞. –°—Ç–∞—Ç—É—Å: 'Check'.")
    return ConversationHandler.END

async def cancel_bible(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    await update.message.reply_text("–û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞.")
    return ConversationHandler.END

bible_conv_handler = ConversationHandler(
    entry_points=[CommandHandler("bible", bible_start)],
    states={
        BIBLE_ASK_ACTION: [MessageHandler(filters.TEXT & ~filters.COMMAND, ask_action)],
        BIBLE_ASK_QUESTION: [MessageHandler(filters.TEXT & ~filters.COMMAND, ask_question)],
        BIBLE_ASK_ANSWER: [MessageHandler(filters.TEXT & ~filters.COMMAND, ask_answer)]
    },
    fallbacks=[CommandHandler("cancel", cancel_bible)]
)

application = ApplicationBuilder().token(TELEGRAM_BOT_TOKEN).build()
bot = application.bot
application.add_handler(bible_conv_handler)

@app.route('/webhook', methods=['POST'])
def telegram_webhook():
    try:
        data = request.get_json(force=True)
        update = Update.de_json(data, bot)
        global_loop.run_until_complete(application.process_update(update))
        return 'OK', 200
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ Telegram update: {e}")
        return jsonify({'error': str(e)}), 500

global_loop = asyncio.new_event_loop()
asyncio.set_event_loop(global_loop)
if __name__ == '__main__':
    port = int(os.getenv("PORT", 8080))
    WEBHOOK_URL = os.getenv("WEBHOOK_URL")
    if not WEBHOOK_URL:
        logger.error("–ù–µ –∑–∞–¥–∞–Ω–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –æ–∫—Ä—É–∂–µ–Ω–∏—è WEBHOOK_URL!")
        exit(1)
    global_loop.run_until_complete(application.initialize())
    global_loop.run_until_complete(bot.set_webhook(WEBHOOK_URL))
    logger.info(f"Webhook —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {WEBHOOK_URL}")
    logger.info(f"–°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É {port}")
    app.run(host='0.0.0.0', port=port, debug=False, threaded=True)
